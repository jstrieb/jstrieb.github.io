<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="author" content="Jacob Strieb" />
  <meta name="date" content="2025-11-04" />
  <meta name="dcterms.date" content="2025-11-04" />
  <meta name="description" content="We go on a journey of discovery to prove my friend wrong (he has a PhD). We learn that ARM instructions are more common than DEFLATE data in random streams." />
  <title>Disassembling Terabytes of Random Data with Zig and Capstone to Prove a Point</title>
  <link rel="stylesheet" href="/style.css" type="text/css" />
</head>
<body>
<div class="menu">
<ul>
<li><a href="/">Home</a></li>
<li><a href="/about/">About</a></li>
<li><a href="/projects/">Projects</a></li>
<li><a href="/posts/">Posts</a></li>
</ul>
<hr />
</div>
<h1 id="disassembling-terabytes-of-random-data-with-zig-and-capstone-to-prove-a-point">Disassembling Terabytes of Random Data with Zig and Capstone to Prove a Point</h1>
<p>By <a href="https://jstrieb.github.io">Jacob Strieb</a>.</p>
<p>Published on <a href="/posts/random-instructions/">November 4, 2025</a>.</p>
<hr />
<style>
* {
  break-inside: avoid;
}

h1, h2, h3, h4, h5, h6 {
  break-after: avoid;
}

table {
  border-collapse: collapse;
  border-spacing: 0;
  margin: 1em auto;
}

tbody tr:hover {
  background: var(--accent-color-1);
}

th, td {
  border: 1px solid var(--fg-color);
  padding: 0.5em 1em;
  text-align: center;
  vertical-align: middle;
}

th {
  white-space: nowrap;
  position: relative;
}

.row {
  display: flex;
  flex-direction: row;
  flex-wrap: wrap;
  justify-content: center;
  align-items: center;
  gap: 1em;
}

figure > div {
  width: 100%;
  overflow-x: auto;
}

figure img {
  /* Derived this filter using my fancy SMT solver code. */
  /* More on this interesting detour another day. */
  filter: invert(1) hue-rotate(88.53602251749824deg);
  border: 1.5px solid rgb(76, 120, 168);
  padding: 0.5rem;
}
</style>
<h1 id="introduction">Introduction</h1>
<p>I had a friendly disagreement the other day. Imagine looking for ARM (<a href="https://en.wikipedia.org/wiki/ARM_architecture_family#Thumb">Thumb</a> mode) instructions in a stream of random bytes. A friend claimed that the random stream is more likely to contain <a href="https://en.wikipedia.org/wiki/Deflate">DEFLATE</a>-compressed Thumb instructions than it is to contain uncompressed Thumb instructions.<a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a> I disagreed.</p>
<p>The gist of his argument was that random bytes have high <a href="https://en.wikipedia.org/wiki/Entropy_(information_theory)">Shannon Entropy</a> in expectation, and compressed bytes have higher entropy than raw assembled instructions. Thus, compressed streams of assembled instructions will be more likely to occur than raw assembled instructions in sequences of random bytes. I don’t debate the premise, but the conclusion does not follow.</p>
<p>I argued that the joint probability of random bytes being a valid DEFLATE stream—<em>and</em> that stream inflating to valid instructions—is lower than the probability of random bytes being valid instructions. Having written a DEFLATE/INFLATE implementation from scratch, I know how many ways there are for compressed data to be invalid. I also know that ARM’s Thumb instruction set is designed for high code density, which directly implies that a large proportion of possible byte sequences disassemble as valid Thumb instructions. Just because the entropy of typical Thumb code in the wild is lower than that of typical compressed data doesn’t mean that the theoretical maximum entropy of valid Thumb is lower too. He was not convinced. I was <a href="https://www.explainxkcd.com/wiki/index.php/356:_Nerd_Sniping">nerd sniped</a>.</p>
<p>Since he has a PhD in an applied field of computer science, I figured he is most likely to be compelled by strong experimental results in a poorly-written, LaTeX-typeset paper with lots of graphs that he can skim and pretend to have read fully. (I’m only mostly joking.)</p>
<p><a href="https://github.com/jstrieb/random-instructions/raw/master/paper/paper.pdf">Here is a link to the typeset PDF research paper version of this post.</a></p>
<h2 id="ai-usage-disclosure">AI Usage Disclosure</h2>
<p>Large Language Models (LLMs) were <strong>not</strong> used for any part of this research. The code and prose are entirely human-written. <a href="https://jstrieb.github.io/posts/llm-thespians/">I wrote a separate post detailing some opinions about LLMs that you should read if you want to know more.</a></p>
<h1 id="methods">Methods</h1>
<p>We write <a href="https://ziglang.org/">Zig</a> code to generate random byte sequences. Then we try to disassemble the bytes using <a href="https://www.capstone-engine.org/">Capstone</a>. We also try to inflate and then disassemble the bytes. We record successes and failures to output statistics at the end.</p>
<p>We test code samples with Zig version 0.14.1.<a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a> Zig changes fast, so it is likely that code samples will need to be modified to work on other versions.</p>
<p><a href="https://github.com/jstrieb/random-instructions/">The full code repository is available on GitHub.</a></p>
<h2 id="capstone-and-zig">Capstone and Zig</h2>
<p>Zig’s build system makes it easy to automatically clone, compile, and link against Capstone.<a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a> Assuming a <code>build.zig</code> file already exists in the working directory (use <code>zig init</code> to create an empty project if not), the following command updates the <code>build.zig.zon</code> file with Capstone as a dependency.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1"></a><span class="ex">zig</span> fetch \</span>
<span id="cb1-2"><a href="#cb1-2"></a>  --save=capstone \</span>
<span id="cb1-3"><a href="#cb1-3"></a>  <span class="st">&#39;git+https://github.com/capstone-engine/capstone.git#5.0.6&#39;</span></span></code></pre></div>
<p>Then we add the following to <code>build.zig</code>.<a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"><sup>4</sup></a></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode zig"><code class="sourceCode zig"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">// There should already be a main executable created in the build script</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">// const exe = b.addExecutable(.{ ... });</span></span>
<span id="cb2-3"><a href="#cb2-3"></a></span>
<span id="cb2-4"><a href="#cb2-4"></a><span class="co">// Build Capstone</span></span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="at">const</span> capstone_dep <span class="op">=</span> b<span class="op">.</span>dependency(<span class="st">&quot;capstone&quot;</span><span class="op">,</span> <span class="op">.</span>{});</span>
<span id="cb2-6"><a href="#cb2-6"></a><span class="at">const</span> capstone_cmake <span class="op">=</span> b<span class="op">.</span>addSystemCommand(<span class="op">&amp;.</span>{</span>
<span id="cb2-7"><a href="#cb2-7"></a>    <span class="st">&quot;cmake&quot;</span><span class="op">,</span></span>
<span id="cb2-8"><a href="#cb2-8"></a>    <span class="st">&quot;-B&quot;</span><span class="op">,</span></span>
<span id="cb2-9"><a href="#cb2-9"></a>    <span class="st">&quot;build&quot;</span><span class="op">,</span></span>
<span id="cb2-10"><a href="#cb2-10"></a>    <span class="st">&quot;-DCMAKE_BUILD_TYPE=Release&quot;</span><span class="op">,</span></span>
<span id="cb2-11"><a href="#cb2-11"></a>    <span class="st">&quot;-DCAPSTONE_BUILD_SHARED_LIBS=1&quot;</span><span class="op">,</span></span>
<span id="cb2-12"><a href="#cb2-12"></a>});</span>
<span id="cb2-13"><a href="#cb2-13"></a>capstone_cmake<span class="op">.</span>setCwd(capstone_dep<span class="op">.</span>path(<span class="st">&quot;&quot;</span>));</span>
<span id="cb2-14"><a href="#cb2-14"></a><span class="at">const</span> capstone_make <span class="op">=</span> b<span class="op">.</span>addSystemCommand(<span class="op">&amp;.</span>{ <span class="st">&quot;cmake&quot;</span><span class="op">,</span> <span class="st">&quot;--build&quot;</span><span class="op">,</span> <span class="st">&quot;build&quot;</span> });</span>
<span id="cb2-15"><a href="#cb2-15"></a>capstone_make<span class="op">.</span>setCwd(capstone_dep<span class="op">.</span>path(<span class="st">&quot;&quot;</span>));</span>
<span id="cb2-16"><a href="#cb2-16"></a>capstone_make<span class="op">.</span>step<span class="op">.</span>dependOn(<span class="op">&amp;</span>capstone_cmake<span class="op">.</span>step);</span>
<span id="cb2-17"><a href="#cb2-17"></a>exe<span class="op">.</span>step<span class="op">.</span>dependOn(<span class="op">&amp;</span>capstone_make<span class="op">.</span>step);</span>
<span id="cb2-18"><a href="#cb2-18"></a></span>
<span id="cb2-19"><a href="#cb2-19"></a><span class="co">// Add the Capstone lib and include directories so we can import capstone.h</span></span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="co">// and link against the Capstone shared object or DLL</span></span>
<span id="cb2-21"><a href="#cb2-21"></a>exe<span class="op">.</span>linkLibC();</span>
<span id="cb2-22"><a href="#cb2-22"></a>exe<span class="op">.</span>addLibraryPath(capstone_dep<span class="op">.</span>path(<span class="st">&quot;build&quot;</span>));</span>
<span id="cb2-23"><a href="#cb2-23"></a>exe<span class="op">.</span>linkSystemLibrary(<span class="st">&quot;capstone&quot;</span>);</span>
<span id="cb2-24"><a href="#cb2-24"></a>exe<span class="op">.</span>addIncludePath(capstone_dep<span class="op">.</span>path(<span class="st">&quot;include&quot;</span>));</span></code></pre></div>
<p>In our <code>main.zig</code> file, we import and use Capstone.<a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a> Our <code>Capstone.disassemble</code> method returns a <code>usize</code> that represents the percentage of disassembled instruction bytes (between 0 and 100, inclusive). We only care the proportion of bytes that successfully disassemble; we don’t care about the disassembled instructions themselves.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode zig"><code class="sourceCode zig"><span id="cb3-1"><a href="#cb3-1"></a><span class="at">const</span> std <span class="op">=</span> <span class="bu">@import</span>(<span class="st">&quot;std&quot;</span>);</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="at">const</span> capstone <span class="op">=</span> <span class="bu">@cImport</span>({</span>
<span id="cb3-3"><a href="#cb3-3"></a>    <span class="bu">@cInclude</span>(<span class="st">&quot;capstone/capstone.h&quot;</span>);</span>
<span id="cb3-4"><a href="#cb3-4"></a>});</span>
<span id="cb3-5"><a href="#cb3-5"></a></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="kw">fn</span> Capstone(arch<span class="op">:</span> capstone<span class="op">.</span>cs_arch<span class="op">,</span> mode<span class="op">:</span> <span class="dt">c_int</span>) <span class="dt">type</span> {</span>
<span id="cb3-7"><a href="#cb3-7"></a>    <span class="cf">return</span> <span class="kw">struct</span> {</span>
<span id="cb3-8"><a href="#cb3-8"></a>        engine<span class="op">:</span> capstone<span class="op">.</span>csh<span class="op">,</span></span>
<span id="cb3-9"><a href="#cb3-9"></a>        <span class="at">const</span> Self <span class="op">=</span> <span class="bu">@This</span>();</span>
<span id="cb3-10"><a href="#cb3-10"></a></span>
<span id="cb3-11"><a href="#cb3-11"></a>        <span class="kw">pub</span> <span class="kw">fn</span> init() <span class="op">!</span>Self {</span>
<span id="cb3-12"><a href="#cb3-12"></a>            <span class="at">var</span> engine<span class="op">:</span> capstone<span class="op">.</span>csh <span class="op">=</span> <span class="cn">undefined</span>;</span>
<span id="cb3-13"><a href="#cb3-13"></a>            <span class="cf">if</span> (capstone<span class="op">.</span>cs_open(arch<span class="op">,</span> mode<span class="op">,</span> <span class="op">&amp;</span>engine) <span class="op">!=</span> capstone<span class="op">.</span>CS_ERR_OK) {</span>
<span id="cb3-14"><a href="#cb3-14"></a>                <span class="cf">return</span> <span class="kw">error</span><span class="op">.</span>CapstoneInitFailed;</span>
<span id="cb3-15"><a href="#cb3-15"></a>            }</span>
<span id="cb3-16"><a href="#cb3-16"></a>            <span class="cf">if</span> (capstone<span class="op">.</span>cs_option(</span>
<span id="cb3-17"><a href="#cb3-17"></a>                engine<span class="op">,</span></span>
<span id="cb3-18"><a href="#cb3-18"></a>                capstone<span class="op">.</span>CS_OPT_SKIPDATA<span class="op">,</span></span>
<span id="cb3-19"><a href="#cb3-19"></a>                capstone<span class="op">.</span>CS_OPT_ON<span class="op">,</span></span>
<span id="cb3-20"><a href="#cb3-20"></a>            ) <span class="op">!=</span> capstone<span class="op">.</span>CS_ERR_OK) {</span>
<span id="cb3-21"><a href="#cb3-21"></a>                <span class="cf">return</span> <span class="kw">error</span><span class="op">.</span>CapstoneInitFailed;</span>
<span id="cb3-22"><a href="#cb3-22"></a>            }</span>
<span id="cb3-23"><a href="#cb3-23"></a>            <span class="cf">return</span> <span class="op">.</span>{ <span class="op">.</span>engine <span class="op">=</span> engine };</span>
<span id="cb3-24"><a href="#cb3-24"></a>        }</span>
<span id="cb3-25"><a href="#cb3-25"></a></span>
<span id="cb3-26"><a href="#cb3-26"></a>        <span class="kw">pub</span> <span class="kw">fn</span> deinit(<span class="va">self</span><span class="op">:</span> <span class="op">*</span>Self) <span class="dt">void</span> {</span>
<span id="cb3-27"><a href="#cb3-27"></a>            _ <span class="op">=</span> capstone<span class="op">.</span>cs_close(<span class="op">&amp;</span><span class="va">self</span><span class="op">.</span>engine);</span>
<span id="cb3-28"><a href="#cb3-28"></a>        }</span>
<span id="cb3-29"><a href="#cb3-29"></a></span>
<span id="cb3-30"><a href="#cb3-30"></a>        <span class="kw">pub</span> <span class="kw">fn</span> disassemble(<span class="va">self</span><span class="op">:</span> Self<span class="op">,</span> b<span class="op">:</span> []<span class="at">const</span> <span class="dt">u8</span>) <span class="dt">usize</span> {</span>
<span id="cb3-31"><a href="#cb3-31"></a>            <span class="cf">if</span> (b<span class="op">.</span>len <span class="op">==</span> <span class="dv">0</span>) <span class="er">return</span> <span class="dv">0</span>;</span>
<span id="cb3-32"><a href="#cb3-32"></a>            <span class="at">var</span> instructions<span class="op">:</span> [<span class="op">*</span>c]capstone<span class="op">.</span>cs_insn <span class="op">=</span> <span class="cn">undefined</span>;</span>
<span id="cb3-33"><a href="#cb3-33"></a>            <span class="at">const</span> count <span class="op">=</span> capstone<span class="op">.</span>cs_disasm(</span>
<span id="cb3-34"><a href="#cb3-34"></a>                <span class="va">self</span><span class="op">.</span>engine<span class="op">,</span></span>
<span id="cb3-35"><a href="#cb3-35"></a>                <span class="bu">@ptrCast</span>(b)<span class="op">,</span></span>
<span id="cb3-36"><a href="#cb3-36"></a>                b<span class="op">.</span>len<span class="op">,</span></span>
<span id="cb3-37"><a href="#cb3-37"></a>                <span class="dv">0</span>,</span>
<span id="cb3-38"><a href="#cb3-38"></a>                <span class="dv">0</span>,</span>
<span id="cb3-39"><a href="#cb3-39"></a>                <span class="op">&amp;</span>instructions<span class="op">,</span></span>
<span id="cb3-40"><a href="#cb3-40"></a>            );</span>
<span id="cb3-41"><a href="#cb3-41"></a>            <span class="cf">defer</span> capstone<span class="op">.</span>cs_free(instructions<span class="op">,</span> count);</span>
<span id="cb3-42"><a href="#cb3-42"></a>            <span class="at">var</span> instruction_bytes<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb3-43"><a href="#cb3-43"></a>            <span class="cf">for</span> (instructions<span class="op">,</span> <span class="dv">0</span><span class="op">..</span>count) <span class="op">|</span>i<span class="op">,</span> _<span class="op">|</span> {</span>
<span id="cb3-44"><a href="#cb3-44"></a>                <span class="cf">if</span> (i<span class="op">.</span>id <span class="op">!=</span> <span class="dv">0</span>) {</span>
<span id="cb3-45"><a href="#cb3-45"></a>                    instruction_bytes <span class="op">+=</span> i<span class="op">.</span>size;</span>
<span id="cb3-46"><a href="#cb3-46"></a>                }</span>
<span id="cb3-47"><a href="#cb3-47"></a>            }</span>
<span id="cb3-48"><a href="#cb3-48"></a>            <span class="cf">return</span> <span class="dv">100</span> * <span class="er">instruction_bytes</span> <span class="op">/</span> b<span class="op">.</span>len;</span>
<span id="cb3-49"><a href="#cb3-49"></a>        }</span>
<span id="cb3-50"><a href="#cb3-50"></a>    };</span>
<span id="cb3-51"><a href="#cb3-51"></a>}</span>
<span id="cb3-52"><a href="#cb3-52"></a></span>
<span id="cb3-53"><a href="#cb3-53"></a><span class="kw">test</span> <span class="st">&quot;basic disassembly&quot;</span> {</span>
<span id="cb3-54"><a href="#cb3-54"></a>    <span class="at">var</span> cs<span class="op">:</span> Capstone(capstone<span class="op">.</span>CS_ARCH_ARM<span class="op">,</span> capstone<span class="op">.</span>CS_MODE_THUMB) <span class="op">=</span> <span class="cf">try</span> <span class="op">.</span>init();</span>
<span id="cb3-55"><a href="#cb3-55"></a>    <span class="cf">defer</span> cs<span class="op">.</span>deinit();</span>
<span id="cb3-56"><a href="#cb3-56"></a></span>
<span id="cb3-57"><a href="#cb3-57"></a>    <span class="cf">try</span> std<span class="op">.</span>testing<span class="op">.</span>expectEqual(<span class="dv">100</span>, <span class="er">cs</span><span class="op">.</span>disassemble(<span class="st">&quot;</span><span class="sc">\xe0\xf9\x4f\x07</span><span class="st">&quot;</span>));</span>
<span id="cb3-58"><a href="#cb3-58"></a>    <span class="cf">try</span> std<span class="op">.</span>testing<span class="op">.</span>expectEqual(<span class="dv">100</span>, <span class="er">cs</span><span class="op">.</span>disassemble(<span class="st">&quot;</span><span class="sc">\x00\x00</span><span class="st">&quot;</span>));</span>
<span id="cb3-59"><a href="#cb3-59"></a>    <span class="cf">try</span> std<span class="op">.</span>testing<span class="op">.</span>expectEqual(<span class="dv">0</span>, <span class="er">cs</span><span class="op">.</span>disassemble(<span class="st">&quot;</span><span class="sc">\x00</span><span class="st">&quot;</span>));</span>
<span id="cb3-60"><a href="#cb3-60"></a>    <span class="cf">try</span> std<span class="op">.</span>testing<span class="op">.</span>expectEqual(<span class="dv">50</span>, <span class="er">cs</span><span class="op">.</span>disassemble(<span class="st">&quot;</span><span class="sc">\xff\xff\x00\x00</span><span class="st">&quot;</span>));</span>
<span id="cb3-61"><a href="#cb3-61"></a>    <span class="cf">try</span> std<span class="op">.</span>testing<span class="op">.</span>expectEqual(<span class="dv">50</span>, <span class="er">cs</span><span class="op">.</span>disassemble(<span class="st">&quot;</span><span class="sc">\x00\x00\xff\xff\xff\xff\x00\x00</span><span class="st">&quot;</span>));</span>
<span id="cb3-62"><a href="#cb3-62"></a>}</span></code></pre></div>
<h2 id="generating-random-bytes">Generating Random Bytes</h2>
<p>We generate random bytes using <a href="https://en.wikipedia.org/wiki/Salsa20">ChaCha</a> seeded by cryptographic randomness. ChaCha is a fast <a href="https://en.wikipedia.org/wiki/Cryptographically_secure_pseudorandom_number_generator">CSPRNG</a>, so it outputs high-quality random bytes, but won’t slow down our hot loop.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode zig"><code class="sourceCode zig"><span id="cb4-1"><a href="#cb4-1"></a><span class="at">var</span> random <span class="op">=</span> random<span class="op">:</span> {</span>
<span id="cb4-2"><a href="#cb4-2"></a>    <span class="at">var</span> seed<span class="op">:</span> [std<span class="op">.</span>Random<span class="op">.</span>ChaCha<span class="op">.</span>secret_seed_length]<span class="dt">u8</span> <span class="op">=</span> <span class="cn">undefined</span>;</span>
<span id="cb4-3"><a href="#cb4-3"></a>    std<span class="op">.</span>crypto<span class="op">.</span>random<span class="op">.</span>bytes(<span class="op">&amp;</span>seed);</span>
<span id="cb4-4"><a href="#cb4-4"></a>    <span class="at">var</span> chacha <span class="op">=</span> std<span class="op">.</span>Random<span class="op">.</span>ChaCha<span class="op">.</span>init(seed);</span>
<span id="cb4-5"><a href="#cb4-5"></a>    <span class="cf">break</span> <span class="op">:</span>random chacha<span class="op">.</span>random();</span>
<span id="cb4-6"><a href="#cb4-6"></a>};</span>
<span id="cb4-7"><a href="#cb4-7"></a></span>
<span id="cb4-8"><a href="#cb4-8"></a><span class="co">// Fill a buffer with random bytes</span></span>
<span id="cb4-9"><a href="#cb4-9"></a><span class="at">var</span> in_buffer<span class="op">:</span> [<span class="dv">128</span>]<span class="er">u8</span> <span class="op">=</span> <span class="cn">undefined</span>;</span>
<span id="cb4-10"><a href="#cb4-10"></a>random<span class="op">.</span>bytes(<span class="op">&amp;</span>in_buffer);</span></code></pre></div>
<h2 id="inflating-bytes">Inflating Bytes</h2>
<p>In Zig 0.14.1, the <a href="https://ziglang.org/documentation/0.14.1/std/#std.compress.flate.inflate.decompress">standard library INFLATE implementation</a> operates on reader and writer streams.<a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a> We build those streams out of pre-allocated buffers, one of which contains the random input data.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode zig"><code class="sourceCode zig"><span id="cb5-1"><a href="#cb5-1"></a><span class="at">var</span> out_buffer<span class="op">:</span> [<span class="dv">128</span> * <span class="er">1</span><span class="dv">0</span><span class="er">2</span><span class="dv">4</span>]<span class="er">u8</span> <span class="op">=</span> <span class="cn">undefined</span>;</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="at">var</span> in_stream <span class="op">=</span> std<span class="op">.</span>io<span class="op">.</span>fixedBufferStream(<span class="op">&amp;</span>in_buffer);</span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="at">var</span> out_stream <span class="op">=</span> std<span class="op">.</span>io<span class="op">.</span>fixedBufferStream(<span class="op">&amp;</span>out_buffer);</span>
<span id="cb5-4"><a href="#cb5-4"></a></span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="cf">try</span> std<span class="op">.</span>compress<span class="op">.</span>flate<span class="op">.</span>inflate<span class="op">.</span>decompress(</span>
<span id="cb5-6"><a href="#cb5-6"></a>    <span class="op">.</span>raw<span class="op">,</span></span>
<span id="cb5-7"><a href="#cb5-7"></a>    in_stream<span class="op">.</span>reader()<span class="op">,</span></span>
<span id="cb5-8"><a href="#cb5-8"></a>    out_stream<span class="op">.</span>writer()<span class="op">,</span></span>
<span id="cb5-9"><a href="#cb5-9"></a>)</span></code></pre></div>
<h2 id="parallelizing">Parallelizing</h2>
<p>To maximize throughput, we run our main loop across all CPU cores. We keep statistics local to each thread, only compiling global results from the thread-local results when the loop terminates. That way the hot loop is lock-free, and we avoid overhead from contention. The downside of this strategy is that we can’t print aggregated statistics while the trials are running.<a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"><sup>7</sup></a></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode zig"><code class="sourceCode zig"><span id="cb6-1"><a href="#cb6-1"></a><span class="at">const</span> total_iterations<span class="op">:</span> <span class="dt">usize</span> <span class="op">=</span> <span class="dv">100_000_000</span>;</span>
<span id="cb6-2"><a href="#cb6-2"></a></span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="at">var</span> results<span class="op">:</span> <span class="kw">struct</span> {</span>
<span id="cb6-4"><a href="#cb6-4"></a>    disasm_count<span class="op">:</span> <span class="dt">u64</span> <span class="op">=</span> <span class="dv">0</span>,</span>
<span id="cb6-5"><a href="#cb6-5"></a>    inflate_count<span class="op">:</span> <span class="dt">u64</span> <span class="op">=</span> <span class="dv">0</span>,</span>
<span id="cb6-6"><a href="#cb6-6"></a>    inflate_disasm_count<span class="op">:</span> <span class="dt">u64</span> <span class="op">=</span> <span class="dv">0</span>,</span>
<span id="cb6-7"><a href="#cb6-7"></a>    lock<span class="op">:</span> std<span class="op">.</span>Thread<span class="op">.</span>Mutex <span class="op">=</span> <span class="op">.</span>{}<span class="op">,</span></span>
<span id="cb6-8"><a href="#cb6-8"></a></span>
<span id="cb6-9"><a href="#cb6-9"></a>    <span class="at">const</span> Self <span class="op">=</span> <span class="bu">@This</span>();</span>
<span id="cb6-10"><a href="#cb6-10"></a></span>
<span id="cb6-11"><a href="#cb6-11"></a>    <span class="kw">pub</span> <span class="kw">fn</span> update(<span class="va">self</span><span class="op">:</span> <span class="op">*</span>Self<span class="op">,</span> disasm_count<span class="op">:</span> <span class="dt">u64</span><span class="op">,</span> inflate_count<span class="op">:</span> <span class="dt">u64</span><span class="op">,</span> inflate_disasm_count<span class="op">:</span> <span class="dt">u64</span>) <span class="dt">void</span> {</span>
<span id="cb6-12"><a href="#cb6-12"></a>        <span class="va">self</span><span class="op">.</span>lock<span class="op">.</span>lock();</span>
<span id="cb6-13"><a href="#cb6-13"></a>        <span class="cf">defer</span> <span class="va">self</span><span class="op">.</span>lock<span class="op">.</span>unlock();</span>
<span id="cb6-14"><a href="#cb6-14"></a>        <span class="va">self</span><span class="op">.</span>disasm_count <span class="op">+=</span> disasm_count;</span>
<span id="cb6-15"><a href="#cb6-15"></a>        <span class="va">self</span><span class="op">.</span>inflate_count <span class="op">+=</span> inflate_count;</span>
<span id="cb6-16"><a href="#cb6-16"></a>        <span class="va">self</span><span class="op">.</span>inflate_disasm_count <span class="op">+=</span> inflate_disasm_count;</span>
<span id="cb6-17"><a href="#cb6-17"></a>    }</span>
<span id="cb6-18"><a href="#cb6-18"></a></span>
<span id="cb6-19"><a href="#cb6-19"></a>    <span class="kw">fn</span> print(<span class="va">self</span><span class="op">:</span> <span class="op">*</span>Self) <span class="op">!</span><span class="dt">void</span> {</span>
<span id="cb6-20"><a href="#cb6-20"></a>      <span class="co">// ...</span></span>
<span id="cb6-21"><a href="#cb6-21"></a>    }</span>
<span id="cb6-22"><a href="#cb6-22"></a>} <span class="op">=</span> <span class="op">.</span>{};</span>
<span id="cb6-23"><a href="#cb6-23"></a></span>
<span id="cb6-24"><a href="#cb6-24"></a><span class="kw">fn</span> loop(iterations<span class="op">:</span> <span class="dt">usize</span>) <span class="op">!</span><span class="dt">void</span> {</span>
<span id="cb6-25"><a href="#cb6-25"></a>    <span class="at">var</span> disasm_count<span class="op">:</span> <span class="dt">u64</span> <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb6-26"><a href="#cb6-26"></a>    <span class="at">var</span> inflate_count<span class="op">:</span> <span class="dt">u64</span> <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb6-27"><a href="#cb6-27"></a>    <span class="at">var</span> inflate_disasm_count<span class="op">:</span> <span class="dt">u64</span> <span class="op">=</span> <span class="dv">0</span>;</span>
<span id="cb6-28"><a href="#cb6-28"></a>    <span class="co">// Other initialization</span></span>
<span id="cb6-29"><a href="#cb6-29"></a></span>
<span id="cb6-30"><a href="#cb6-30"></a>    <span class="cf">for</span> (<span class="dv">0</span><span class="op">..</span>iterations) <span class="op">|</span>_<span class="op">|</span> {</span>
<span id="cb6-31"><a href="#cb6-31"></a>        <span class="co">// Do stuff...</span></span>
<span id="cb6-32"><a href="#cb6-32"></a>    }</span>
<span id="cb6-33"><a href="#cb6-33"></a></span>
<span id="cb6-34"><a href="#cb6-34"></a>    results<span class="op">.</span>update(disasm_count<span class="op">,</span> inflate_count<span class="op">,</span> inflate_disasm_count);</span>
<span id="cb6-35"><a href="#cb6-35"></a>}</span>
<span id="cb6-36"><a href="#cb6-36"></a></span>
<span id="cb6-37"><a href="#cb6-37"></a><span class="kw">pub</span> <span class="kw">fn</span> main() <span class="op">!</span><span class="dt">void</span> {</span>
<span id="cb6-38"><a href="#cb6-38"></a>    <span class="at">const</span> thread_count <span class="op">=</span> <span class="bu">@min</span>(std<span class="op">.</span>Thread<span class="op">.</span>getCpuCount() <span class="cf">catch</span> <span class="dv">1</span>, <span class="er">1</span><span class="dv">0</span><span class="er">2</span><span class="dv">4</span>);</span>
<span id="cb6-39"><a href="#cb6-39"></a>    <span class="at">var</span> thread_buffer<span class="op">:</span> [<span class="dv">1024</span>]<span class="er">std</span><span class="op">.</span>Thread <span class="op">=</span> <span class="cn">undefined</span>;</span>
<span id="cb6-40"><a href="#cb6-40"></a>    <span class="at">const</span> threads <span class="op">=</span> thread_buffer[<span class="dv">0</span><span class="op">..</span>thread_count];</span>
<span id="cb6-41"><a href="#cb6-41"></a>    <span class="at">const</span> iterations <span class="op">=</span> total_iterations <span class="op">/</span> thread_count;</span>
<span id="cb6-42"><a href="#cb6-42"></a>    <span class="cf">for</span> (threads) <span class="op">|*</span>t<span class="op">|</span> {</span>
<span id="cb6-43"><a href="#cb6-43"></a>        t<span class="op">.*</span> <span class="op">=</span> <span class="cf">try</span> std<span class="op">.</span>Thread<span class="op">.</span>spawn(<span class="op">.</span>{}<span class="op">,</span> loop<span class="op">,</span> <span class="op">.</span>{iterations});</span>
<span id="cb6-44"><a href="#cb6-44"></a>    }</span>
<span id="cb6-45"><a href="#cb6-45"></a>    <span class="cf">for</span> (threads) <span class="op">|</span>t<span class="op">|</span> {</span>
<span id="cb6-46"><a href="#cb6-46"></a>        t<span class="op">.</span>join();</span>
<span id="cb6-47"><a href="#cb6-47"></a>    }</span>
<span id="cb6-48"><a href="#cb6-48"></a>    <span class="cf">try</span> results<span class="op">.</span>print();</span>
<span id="cb6-49"><a href="#cb6-49"></a>}</span></code></pre></div>
<h2 id="collecting-decompression-errors">Collecting Decompression Errors</h2>
<p>To collect decompression errors, we use Zig compile-time (comptime) metaprogramming. At comptime, we build an array of all possible errors returned from the decompression function. We use that array to initialize a corresponding array of counts, where we tally the number of occurrences of each error.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode zig"><code class="sourceCode zig"><span id="cb7-1"><a href="#cb7-1"></a><span class="at">const</span> errors <span class="op">=</span> errors<span class="op">:</span> {</span>
<span id="cb7-2"><a href="#cb7-2"></a>    <span class="at">const</span> error_set <span class="op">=</span> <span class="bu">@typeInfo</span>(</span>
<span id="cb7-3"><a href="#cb7-3"></a>        <span class="bu">@typeInfo</span>(</span>
<span id="cb7-4"><a href="#cb7-4"></a>            <span class="bu">@TypeOf</span>(result<span class="op">:</span> {</span>
<span id="cb7-5"><a href="#cb7-5"></a>                <span class="at">var</span> in_stream <span class="op">=</span> std<span class="op">.</span>io<span class="op">.</span>fixedBufferStream(<span class="op">&amp;</span>[_]<span class="dt">u8</span>{});</span>
<span id="cb7-6"><a href="#cb7-6"></a>                <span class="cf">break</span> <span class="op">:</span>result std<span class="op">.</span>compress<span class="op">.</span>flate<span class="op">.</span>inflate<span class="op">.</span>decompress(</span>
<span id="cb7-7"><a href="#cb7-7"></a>                    <span class="op">.</span>raw<span class="op">,</span></span>
<span id="cb7-8"><a href="#cb7-8"></a>                    in_stream<span class="op">.</span>reader()<span class="op">,</span></span>
<span id="cb7-9"><a href="#cb7-9"></a>                    std<span class="op">.</span>io<span class="op">.</span>NullWriter{ <span class="op">.</span>context <span class="op">=</span> {} }<span class="op">,</span></span>
<span id="cb7-10"><a href="#cb7-10"></a>                );</span>
<span id="cb7-11"><a href="#cb7-11"></a>            })<span class="op">,</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>        )<span class="op">.</span>error_union<span class="op">.</span>error_set<span class="op">,</span></span>
<span id="cb7-13"><a href="#cb7-13"></a>    )<span class="op">.</span>error_set<span class="op">.?</span>;</span>
<span id="cb7-14"><a href="#cb7-14"></a>    <span class="at">const</span> num_errors <span class="op">=</span> error_set<span class="op">.</span>len;</span>
<span id="cb7-15"><a href="#cb7-15"></a>    <span class="at">var</span> result<span class="op">:</span> [num_errors]<span class="dt">anyerror</span> <span class="op">=</span> <span class="cn">undefined</span>;</span>
<span id="cb7-16"><a href="#cb7-16"></a>    <span class="cf">for</span> (error_set<span class="op">,</span> <span class="dv">0</span><span class="op">..</span>) <span class="op">|</span>err<span class="op">,</span> i<span class="op">|</span> {</span>
<span id="cb7-17"><a href="#cb7-17"></a>        result[i] <span class="op">=</span> <span class="bu">@field</span>(<span class="dt">anyerror</span><span class="op">,</span> err<span class="op">.</span>name);</span>
<span id="cb7-18"><a href="#cb7-18"></a>    }</span>
<span id="cb7-19"><a href="#cb7-19"></a>    <span class="cf">break</span> <span class="op">:</span>errors result;</span>
<span id="cb7-20"><a href="#cb7-20"></a>};</span>
<span id="cb7-21"><a href="#cb7-21"></a><span class="at">var</span> counts <span class="op">=</span> [_]<span class="dt">usize</span>{ <span class="dv">0</span> } ** <span class="er">errors</span><span class="op">.</span>len;</span></code></pre></div>
<p>Notice that to <a href="https://en.wikipedia.org/wiki/Reification_(computer_science)">reify</a> an error from its name, we use <code>@field(anyerror, name)</code>. This works because <code>anyerror</code> can be considered an enum that collects all errors reachable in the compilation unit.<a href="#fn8" class="footnote-ref" id="fnref8" role="doc-noteref"><sup>8</sup></a> Hence, every possible Zig error is a field of that global enum.</p>
<p>Reifying errors from their names is important for inlining the mapping between returned errors and their corresponding index in the <code>counts</code> array. It is faster to check the equality of the received error and the expected error directly than to serialize the received error to a name and then do string comparison.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode zig"><code class="sourceCode zig"><span id="cb8-1"><a href="#cb8-1"></a><span class="cf">if</span> (std<span class="op">.</span>compress<span class="op">.</span>flate<span class="op">.</span>inflate<span class="op">.</span>decompress(</span>
<span id="cb8-2"><a href="#cb8-2"></a>    <span class="op">.</span>raw<span class="op">,</span></span>
<span id="cb8-3"><a href="#cb8-3"></a>    in_stream<span class="op">.</span>reader()<span class="op">,</span></span>
<span id="cb8-4"><a href="#cb8-4"></a>    std<span class="op">.</span>io<span class="op">.</span>NullWriter{ <span class="op">.</span>context <span class="op">=</span> {} }<span class="op">,</span></span>
<span id="cb8-5"><a href="#cb8-5"></a>)) {</span>
<span id="cb8-6"><a href="#cb8-6"></a>    inflate_count <span class="op">+=</span> <span class="dv">1</span>;</span>
<span id="cb8-7"><a href="#cb8-7"></a>} <span class="cf">else</span> <span class="op">|</span>e<span class="op">|</span> {</span>
<span id="cb8-8"><a href="#cb8-8"></a>    <span class="kw">inline</span> <span class="cf">for</span> (errors<span class="op">,</span> <span class="dv">0</span><span class="op">..</span>) <span class="op">|</span>err<span class="op">,</span> i<span class="op">|</span> {</span>
<span id="cb8-9"><a href="#cb8-9"></a>        <span class="cf">if</span> (err <span class="op">==</span> e) {</span>
<span id="cb8-10"><a href="#cb8-10"></a>            counts[i] <span class="op">+=</span> <span class="dv">1</span>;</span>
<span id="cb8-11"><a href="#cb8-11"></a>            <span class="cf">break</span>;</span>
<span id="cb8-12"><a href="#cb8-12"></a>        }</span>
<span id="cb8-13"><a href="#cb8-13"></a>    }</span>
<span id="cb8-14"><a href="#cb8-14"></a>}</span></code></pre></div>
<h2 id="final-script">Final Script</h2>
<p><a href="https://github.com/jstrieb/random-instructions/blob/master/src/main.zig">The full script that combines each of these parts is available in the GitHub repository</a>.</p>
<h1 id="results">Results</h1>
<p>The most important result is that <strong>successful disassembly is over 125x more common than successful decompression, and over 350x more common than decompression <em>and</em> disassembly</strong>.</p>
<figure>
<div>
<table>
<tbody>
<tr>
<td>
Total
</td>
<td style="text-align: right;">
1,000,000,000
</td>
</tr>
<tr>
<td>
Disassembled
</td>
<td style="text-align: right;">
642,628,412
</td>
</tr>
<tr>
<td>
Decompressed
</td>
<td style="text-align: right;">
5,037,627
</td>
</tr>
<tr>
<td>
Decompressed and disassembled
</td>
<td style="text-align: right;">
1,810,170
</td>
</tr>
</tbody>
</table>
</div>
<img src="totals.svg" />
<figcaption>
Statistics for 1,000,000,000 random 128-byte buffers, counting instances that disassemble 95% or more of the bytes.
</figcaption>
</figure>
<h2 id="disassembly-results">Disassembly Results</h2>
<p>Given that about 65% of 128-byte buffers consist of at least 95% valid Thumb instructions, there are two natural questions: since most Thumb instructions are two bytes long, what proportion of 2-byte sequences are valid Thumb instructions? And what percentage of 128-byte buffers consist <em>entirely</em> of valid Thumb instructions?</p>
<figure>
<div>
<table>
<tbody>
<tr>
<td>
Total
</td>
<td style="text-align: right;">
1,000,000,000
</td>
</tr>
<tr>
<td>
Disassembled
</td>
<td style="text-align: right;">
892,800,538
</td>
</tr>
</tbody>
</table>
</div>
<figcaption>
Statistics for 1,000,000,000 random 2-byte buffers, counting instances that disassemble completely.
</figcaption>
</figure>
<p>According to our measurements, any 2-byte sequence has an 89.3% chance of disassembling as a valid Thumb instruction. Evidently, Thumb has very high code density.</p>
<p>Note that <a href="https://developer.arm.com/documentation/ddi0403/d/Application-Level-Architecture/The-Thumb-Instruction-Set-Encoding/32-bit-Thumb-instruction-encoding?lang=en">some few Thumb instructions assemble as four bytes</a>, so we cannot assume that every pair of bytes has an independent, identically (<a href="https://en.wikipedia.org/wiki/Bernoulli_distribution">Bernoulli</a>) distributed probability of being part of a valid assembly sequence. Our measurements indicate that 855,008,565 (or 85.5%) of 1,000,000,000 4-byte buffers disassembled completely as valid Thumb instructions, compared with the <span class="math inline">0.892<sup>2</sup> ≈ 79.7%</span> rate we would expect if all Thumb instructions were 2-bytes long.</p>
<p>Though we can’t assume every pair of bytes is independent of every other pair, we may assume that every 4-byte sequence is independent and identically distributed in terms of the probability of successful disassembly. Using this assumption, we can approximately predict the proportion of fully disassembled 128-byte sequences.</p>
<p><br /><span class="math display">0.855008565<sup>(128/4)</sup> = 0.006653572 ≈ 6.65%</span><br /></p>
<p>Compare our prediction with the actual, measured incidence of 4.47% of 128-byte buffers that completely disassemble.</p>
<figure>
<div>
<table>
<tbody>
<tr>
<td>
Total
</td>
<td style="text-align: right;">
1,000,000,000
</td>
</tr>
<tr>
<td>
Disassembled
</td>
<td style="text-align: right;">
44,726,130
</td>
</tr>
<tr>
<td>
Decompressed
</td>
<td style="text-align: right;">
5,036,173
</td>
</tr>
<tr>
<td>
Decompressed and disassembled
</td>
<td style="text-align: right;">
1,577,559
</td>
</tr>
</tbody>
</table>
</div>
<img src="totals100.svg" />
<figcaption>
Statistics for 1,000,000,000 random 128-byte buffers, counting instances that disassemble 100% of the bytes.
</figcaption>
</figure>
<p>Even when we require 100% of bytes to disassemble as valid Thumb instructions, there are still an order of magnitude more buffers that disassemble than decompress.</p>
<p>If we assume groups of four consecutive bytes have an independent and identically distributed probability of successful disassembly, we expect the likelihood of completely disassembling a buffer to decay exponentially relative to the size of the buffer. In other words, the probability of finding a sequence that does <em>not</em> disassemble should quickly approach 1 as the size of the buffer increases. The experimental results validate that theoretical prediction.</p>
<figure>
<img src="all100.svg" />
<figcaption>
Statistics for 1,000,000,000 random buffers of each size (in bytes), counting instances that disassemble 100% of the bytes.
</figcaption>
</figure>
<p>Also, unsurprisingly, as the minimum threshold for successful disassembly decreases, the proportion of successes increases for each buffer size.</p>
<figure>
<img src="thresholds.svg" />
<figcaption>
Statistics for 1,000,000,000 random buffers of each size (in bytes) and threshold for disassembly, counting instances that disassemble at least the threshold percent of the bytes.
</figcaption>
</figure>
<h2 id="decompression-results">Decompression Results</h2>
<p>Based on our experiments, we know why disassembly is likely to succeed. But, independent of successful disassembly, why is decompression likely to fail?</p>
<p>The rate of successful decompression is fairly constant for buffers above 32 bytes in size.</p>
<figure>
<img src="inflate_rate.svg" />
<figcaption>
Statistics for 1,000,000,000 random buffers of each size (in bytes), counting instances that decompress successfully.
</figcaption>
</figure>
<p>This suggests that the majority of errors from unsuccessful decompression happen in the first 32 bytes of the buffer, which makes sense, since that is where the small DEFLATE header would be found for valid compressed streams. In other words, it’s unlikely that random bytes make a valid DEFLATE header. But if the header is valid, the rest is likely to successfully decompress, regardless of buffer size.</p>
<p>The errors returned when decompression fails corroborate the hypothesis that failures are primarily caused by invalid DEFLATE metadata.</p>
<figure>
<div>
<table>
<tbody>
<tr>
<td>
Total
</td>
<td style="text-align: right;">
1,000,000,000
</td>
</tr>
<tr>
<td>
Success
</td>
<td style="text-align: right;">
5,030,965
</td>
</tr>
<tr>
<td>
Wrong Stored Block Nlen
</td>
<td style="text-align: right;">
251,255,219
</td>
</tr>
<tr>
<td>
Invalid Block Type
</td>
<td style="text-align: right;">
251,254,609
</td>
</tr>
<tr>
<td>
Invalid Match
</td>
<td style="text-align: right;">
214,744,118
</td>
</tr>
<tr>
<td>
Oversubscribed Huffman Tree
</td>
<td style="text-align: right;">
146,011,334
</td>
</tr>
<tr>
<td>
Incomplete Huffman Tree
</td>
<td style="text-align: right;">
74,024,330
</td>
</tr>
<tr>
<td>
Invalid Dynamic Block Header
</td>
<td style="text-align: right;">
31,141,638
</td>
</tr>
<tr>
<td>
Invalid Code
</td>
<td style="text-align: right;">
26,438,043
</td>
</tr>
<tr>
<td>
Missing End of Block Code
</td>
<td style="text-align: right;">
95,816
</td>
</tr>
<tr>
<td>
End of Stream
</td>
<td style="text-align: right;">
3,928
</td>
</tr>
</tbody>
</table>
</div>
<img src="inflate_errors.svg" />
<figcaption>
Statistics for 1,000,000,000 random 128-byte buffers, counting the errors that are returned when decompression fails.
</figcaption>
</figure>
<p>To understand these errors completely, we must explore the structure of the DEFLATE stream.</p>
<h3 id="deflate-structure">DEFLATE Structure</h3>
<p>A DEFLATE stream consists of one or more blocks. The first bit of every block denotes whether it is the final block in the stream.<a href="#fn9" class="footnote-ref" id="fnref9" role="doc-noteref"><sup>9</sup></a> If the first bit is <code>1</code>, the decompressor terminates when it sees an “end of block” token. On the other hand, if the first bit is <code>0</code>, the decompressor will look for <em>another</em> valid DEFLATE header after an end of block token in the stream. Thus, in that case, there is an additional opportunity for any of the errors that could have caused decompression to fail on the first block header.</p>
<p>As a result, we can reduce the failure rate for most classes of error by fixing the first bit of the stream to be <code>1</code>, so that only one valid header is required, instead of two or more.</p>
<figure>
<div>
<table>
<thead>
<tr>
<td>
</td>
<td>
First bit 0
</td>
<td>
First bit 1
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
Total
</td>
<td style="text-align: right;">
1,000,000,000
</td>
<td style="text-align: right;">
1,000,000,000
</td>
</tr>
<tr>
<td>
Success
</td>
<td style="text-align: right;">
56,372
</td>
<td style="text-align: right;">
10,010,648
</td>
</tr>
<tr>
<td>
Wrong Stored Block Nlen
</td>
<td style="text-align: right;">
252,530,381
</td>
<td style="text-align: right;">
250,005,035
</td>
</tr>
<tr>
<td>
Invalid Block Type
</td>
<td style="text-align: right;">
252,495,113
</td>
<td style="text-align: right;">
249,999,800
</td>
</tr>
<tr>
<td>
Invalid Match
</td>
<td style="text-align: right;">
215,816,449
</td>
<td style="text-align: right;">
213,698,259
</td>
</tr>
<tr>
<td>
Oversubscribed Huffman Tree
</td>
<td style="text-align: right;">
146,737,762
</td>
<td style="text-align: right;">
145,281,110
</td>
</tr>
<tr>
<td>
Incomplete Huffman Tree
</td>
<td style="text-align: right;">
74,398,039
</td>
<td style="text-align: right;">
73,635,423
</td>
</tr>
<tr>
<td>
Invalid Dynamic Block Header
</td>
<td style="text-align: right;">
31,290,580
</td>
<td style="text-align: right;">
30,987,133
</td>
</tr>
<tr>
<td>
Invalid Code
</td>
<td style="text-align: right;">
26,574,767
</td>
<td style="text-align: right;">
26,283,441
</td>
</tr>
<tr>
<td>
Missing End of Block Code
</td>
<td style="text-align: right;">
96,424
</td>
<td style="text-align: right;">
95,216
</td>
</tr>
<tr>
<td>
End of Stream
</td>
<td style="text-align: right;">
4,113
</td>
<td style="text-align: right;">
3,935
</td>
</tr>
</tbody>
</table>
</div>
<img src="inflate_1_bit.svg" />
<figcaption>
Statistics for 1,000,000,000 random 128-byte buffers with the first bit fixed to either <code>0</code> or <code>1</code>, counting the errors that are returned when decompression fails.
</figcaption>
</figure>
<p>The second and third bits of the DEFLATE block header denote how the data is encoded.<a href="#fn10" class="footnote-ref" id="fnref10" role="doc-noteref"><sup>10</sup></a> There are four possible options for these two bits, and three of the four options are considered valid.</p>
<p>A value of <code>11</code> for the second and third bits is considered invalid, and the decompressor will return an “invalid block type” error in that case. Because this pattern occurs for one in four random streams (in expectation), it accounts for approximately 25% of the attempts that end in decompression failure. Setting the second and third bits to <code>11</code> makes 100% of decompression attempts fail.</p>
<figure>
<div>
<table>
<tbody>
<tr>
<td>
Total
</td>
<td style="text-align: right;">
1,000,000,000
</td>
</tr>
<tr>
<td>
Success
</td>
<td style="text-align: right;">
0
</td>
</tr>
<tr>
<td>
Invalid Block Type
</td>
<td style="text-align: right;">
1,000,000,000
</td>
</tr>
</tbody>
</table>
</div>
<figcaption>
Statistics for 1,000,000,000 random 128-byte buffers with the first three bits fixed to <code>111</code>, counting the errors that are returned when decompression fails.
</figcaption>
</figure>
<p>If the second and third bits are <code>00</code>, the data is included “raw” – it is not encoded or compressed before being included in the stream. In this case, the second and third bytes of the stream represent the length of the raw data, and the two bytes after that are their ones’ complement (logical negation). According to the <a href="https://datatracker.ietf.org/doc/html/rfc1951#page-11">DEFLATE specification</a>, the data after the first byte in a raw DEFLATE stream looks like this:</p>
<pre><code>  2   3   4   5   6...
+---+---+---+---+=================================+
|  LEN  | NLEN  |... LEN bytes of literal data ...|
+---+---+---+---+=================================+</code></pre>
<p>The likelihood of the fourth and fifth bytes being the exact ones’ complement of the second and third bytes is:</p>
<p><br /><span class="math display">1 / 2<sup>16</sup> ≈ 0.0015258789%</span><br /></p>
<p>The extremely low probability of success for the raw block type explains another ~25% of decompression attempts that end in failure with the “wrong stored block nlen” error. Setting the second and third bits to <code>00</code> makes almost all of the decompression attempts fail.</p>
<figure>
<div>
<table>
<tbody>
<tr>
<td>
Total
</td>
<td style="text-align: right;">
1,000,000,000
</td>
</tr>
<tr>
<td>
Success
</td>
<td style="text-align: right;">
24
</td>
</tr>
<tr>
<td>
Wrong Stored Block Nlen
</td>
<td style="text-align: right;">
999,984,702
</td>
</tr>
<tr>
<td>
End of Stream
</td>
<td style="text-align: right;">
15,274
</td>
</tr>
</tbody>
</table>
</div>
<figcaption>
Statistics for 1,000,000,000 random 128-byte buffers with the first three bits fixed to <code>100</code>, counting the errors that are returned when decompression fails.
</figcaption>
</figure>
<p>In the other two block modes, raw data is first <a href="https://en.wikipedia.org/wiki/LZ77_and_LZ78">LZ77-encoded</a>, then <a href="https://en.wikipedia.org/wiki/Huffman_coding">Huffman-encoded</a> to compress it. In Huffman coding, an efficient bit representation of each symbol is generated from the frequency distribution of symbols in the uncompressed data. Symbols that appear more frequently will be represented using fewer bits. The rules for decoding symbols from bits are stored as a “Huffman tree” data structure.</p>
<p>If the second and third bits of the DEFLATE stream are <code>01</code>, the data is decoded using a hard-coded (“static”) Huffman tree whose structure is specified in the DEFLATE specification. If the second and third bits are <code>10</code> instead, the Huffman tree was built dynamically, and is included in the stream itself. Using the hard-coded Huffman tree typically leads to worse compression ratios than using a dynamic Huffman tree, but the static tree was more useful for our purpose of decompressing random bytes since it presents fewer opportunities for erroneous header data.</p>
<figure>
<div>
<table>
<thead>
<tr>
<td>
</td>
<td>
Dynamic Huffman Code
</td>
<td>
Static Huffman Code
</td>
</tr>
</thead>
<tbody>
<tr>
<td>
Total
</td>
<td style="text-align: right;">
1,000,000,000
</td>
<td style="text-align: right;">
1,000,000,000
</td>
</tr>
<tr>
<td>
Success
</td>
<td style="text-align: right;">
0
</td>
<td style="text-align: right;">
40,055,267
</td>
</tr>
<tr>
<td>
End of Stream
</td>
<td style="text-align: right;">
233
</td>
<td style="text-align: right;">
570
</td>
</tr>
<tr>
<td>
Invalid Code
</td>
<td style="text-align: right;">
15,254
</td>
<td style="text-align: right;">
105,125,696
</td>
</tr>
<tr>
<td>
Oversubscribed Huffman Tree
</td>
<td style="text-align: right;">
581,086,654
</td>
<td style="text-align: right;">
0
</td>
</tr>
<tr>
<td>
Incomplete Huffman Tree
</td>
<td style="text-align: right;">
294,586,455
</td>
<td style="text-align: right;">
0
</td>
</tr>
<tr>
<td>
Missing End of Block Code
</td>
<td style="text-align: right;">
380,197
</td>
<td style="text-align: right;">
0
</td>
</tr>
<tr>
<td>
Invalid Match
</td>
<td style="text-align: right;">
0
</td>
<td style="text-align: right;">
854,818,467
</td>
</tr>
<tr>
<td>
Invalid Dynamic Block Header
</td>
<td style="text-align: right;">
123,931,207
</td>
<td style="text-align: right;">
0
</td>
</tr>
</tbody>
</table>
</div>
<img src="inflate_huffman_trees.svg" />
<figcaption>
Statistics for 1,000,000,000 random 128-byte buffers with the first three bits fixed to either <code>101</code> or <code>110</code>, counting the errors that are returned when decompression fails.
</figcaption>
</figure>
<p>In order to refute the strongest version of the claim that decompressing and then disassembling random bytes is more likely to succeed than just disassembling random bytes, we re-run our initial test after fixing the first three bits of the random buffer to <code>110</code>. That way the otherwise random bytes are always considered the final block in the stream, and always use static Huffman codes to avoid header errors.</p>
<figure>
<div>
<table>
<tbody>
<tr>
<td>
Total
</td>
<td style="text-align: right;">
1,000,000,000
</td>
</tr>
<tr>
<td>
Disassembled
</td>
<td style="text-align: right;">
44,724,849
</td>
</tr>
<tr>
<td>
Decompressed
</td>
<td style="text-align: right;">
40,056,259
</td>
</tr>
<tr>
<td>
Decompressed and disassembled
</td>
<td style="text-align: right;">
12,543,383
</td>
</tr>
</tbody>
</table>
</div>
<img src="totals_static_tree.svg" />
<figcaption>
Statistics for 1,000,000,000 random 128-byte buffers with the first three bits fixed to <code>110</code> before decompressing (for static Huffman trees), counting instances that disassemble 100% of the bytes.
</figcaption>
</figure>
<p>Though the rates of success are much closer, even in this most generous case, disassembly is more likely than decompression, and once again much more likely than decompression <em>and</em> disassembly.</p>
<h2 id="other-architectures">Other Architectures</h2>
<p>Besides ARM in Thumb mode, Capstone supports disassembling a <a href="https://github.com/capstone-engine/capstone/blob/5.0.6/include/capstone/capstone.h#L132-L231">wide variety of other architectures and modes</a>. Using <a href="https://jstrieb.github.io/posts/c-reflection-zig/">C macro reflection in Zig</a>, we can re-run our randomized disassembly across all available architectures and modes.</p>
<p>In many architectures, instruction disassembly is stateful, and is conditioned on previous instructions (especially when assembled instructions have variable length, such as in x86). As a result, many other architectures do not admit the assumption that aligned, fixed-sized buffer subsections have an independent probability of being disassembled successfully.</p>
<figure>
<img src="isas95.svg" />
<figcaption>
Statistics for 10,000,000 random 128-byte buffers, counting instances that disassemble at least 95% of the bytes.
</figcaption>
</figure>
<figure>
<img src="isas100.svg" />
<figcaption>
Statistics for 10,000,000 random 4-byte buffers, counting instances that disassemble 100% of the bytes.
</figcaption>
</figure>
<h2 id="performance">Performance</h2>
<p>Overall, the Monte Carlo code that powers these “experiments” is very performant. Zig is a fast language, and even without any deliberate optimization, the code can disassemble and decompress one billion 128-byte buffers in about a half hour on the 10-year-old, 48-core server we used for testing.</p>
<pre><code>jacob@jacob:random-instructions$ time ./zig-out/bin/random_instructions --total-iterations 1_000_000_000 --disassembly-threshold 100
[ ... ]

real    30m35.158s
user    1396m34.236s
sys     1m0.426s</code></pre>
<p>Most of the computation time was spent in Capstone. Without profiling in detail, we suspect that overhead from dynamic memory allocation performed inside of Capstone during disassembly accounts for a significant portion of that time. The code is fast enough for testing that it wasn’t worth experimenting with different allocator implementations in Capstone. It likewise wasn’t worth doing any detailed profiling.</p>
<p>The program’s running times scaled approximately linearly with the size of the input buffer. There was no evidence of the disassembly threshold impacting the running time, nor was there an impact on decompression time resulting from fixing particular starting bits.</p>
<p>Adding evidence to the theory that Capstone was the slowest part of the code, the throughput of <a href="https://github.com/jstrieb/random-instructions/blob/master/src/inflate.zig">a different script that only decompressed without attempting to disassemble</a> was much higher. In a randomly chosen run, that script decompressed one billion 128-byte buffers in 5 minutes and 46 seconds.</p>
<pre><code>jacob@jacob:random-instructions$ time ./zig-out/bin/random_inflate --total-iterations 1_000_000_000
[ ... ]

real    5m46.619s
user    261m22.503s
sys     1m6.833s

jacob@jacob:random-instructions$ time ./zig-out/bin/random_inflate --total-iterations 1_000_000_000 --first-bits 0b011 --num-bits 3
[ ... ]

real    5m47.705s
user    262m18.896s
sys     1m6.702s
</code></pre>
<p>In other words, without any particular optimizations, that program had a decompression throughput upper-bounded by:<a href="#fn11" class="footnote-ref" id="fnref11" role="doc-noteref"><sup>11</sup></a></p>
<p><br /><span class="math display">(128 × 1000000000) / (5 × 60 + 46) = 369942197 bytes per second ≈ 345 MB/s</span><br /></p>
<p><a href="https://github.com/jstrieb/random-instructions/blob/master/graphs/">The code and raw data used to generate the graphs are on GitHub.</a></p>
<h1 id="conclusion">Conclusion</h1>
<p>Our theoretical and experimental results point clearly to one conclusion: Thumb instructions have very high code density, and are much more likely to occur in sequences of random bytes than compressed data (especially more likely than compressed data containing valid Thumb instructions).</p>
<p>Even in cases where we artificially modify the random data before decompressing it to make it as likely as possible to decompress, it is still less likely to decompress than disassemble.</p>
<p>Zig makes it fun to write fast code, and was pretty awesome to use for this exploratory analysis. If you’ve not heard of it, you should definitely check it out.</p>
<h1 id="further-research">Further Research</h1>
<p>Other ISAs supported by Capstone show varying code density, and it would be worth researching better candidates than Thumb for maximizing the likelihood of successful disassembly of random byte sequences. For example, does M680X actually have absurdly high code density, or was there a methodological error or code bug artificially inflating its disassembly success rate?</p>
<p>We have done no work to assess whether the instruction sequences appearing in our random buffers are of particular interest. It would be unsurprising if an instruction set with relatively low code density (and therefore low rate of random disassembly success) might have a higher likelihood of useful instruction sequences appearing in random byte streams, compared with a dense instruction set with a high likelihood of disassembly.</p>
<p>There might be other ways to cook up the header of a DEFLATE stream to maximize the decompression likelihood of an otherwise random stream. For example, is it possible to craft a “dynamic” Huffman tree (that we insert at the beginning of every random sequence) that maximizes the likelihood of successful decompression?</p>
<p>If anyone continues this research, please <a href="https://jstrieb.github.io/about#contact">email me or use my contact form to notify me of your results</a>.</p>
<h1 id="references">References</h1>
<p>Nice try, but this isn’t actually a real research paper. I hope you weren’t hoping for APA-style citations or any such nonsense. The important references are linked inline.</p>
<!-- 
  Apparently browsers cannot automatically hyphenate capitalized words. So I
  guess I'll just go fuck myself.
-->
<h1 id="acknowledgments">Acknowledg­ments</h1>
<p>Thanks to <a href="https://github.com/lsnow99">Logan Snow</a> and <a href="https://www.youtube.com/@Liuamyjane">Amy Liu</a> for reading early versions of this post.</p>
<p>Shout out to my anonymous friend whose incorrect—but strongly-held—convictions inspired this work in the first place.</p>
<section class="footnotes" role="doc-endnotes">
<hr />
<ol>
<li id="fn1" role="doc-endnote"><p>He was actually arguing that <a href="https://www.rfc-editor.org/rfc/rfc1950.html">ZLIB-compressed</a> Thumb instructions (the format that wraps DEFLATE and is found in PNG files, not the zlib library) would be most likely, but I’m refuting a stronger version of his argument. A DEFLATE stream without headers and checksums is strictly more likely to randomly appear than a stream with them.<a href="#fnref1" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2" role="doc-endnote"><p>Version 0.14.1 was the latest at the time of writing, but not the latest at the time of publishing.<a href="#fnref2" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn3" role="doc-endnote"><p>I could have used <a href="https://github.com/allyourcodebase/capstone">the version of Capstone ported to the Zig build system</a>, but I didn’t think to look for it when I first started this. Building it myself was the first thing I tried, and it worked.<a href="#fnref3" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4" role="doc-endnote"><p>The version of <a href="https://github.com/jstrieb/random-instructions/blob/master/build.zig"><code>build.zig</code> in the repo</a> is more complicated because we cross-compile Capstone using Zig and (optionally) statically link, instead of building only for the host architecture and enforcing dynamic linking. The statically-linked version runs slower, likely due to <a href="https://nickb.dev/blog/default-musl-allocator-considered-harmful-to-performance/">known performance issues with the default musl libc allocator</a>. Unsurprisingly, allocating in the hot path is bad for performance.<a href="#fnref4" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn5" role="doc-endnote"><p>It appears that Capstone does dynamic memory allocation when we call the <code>cs_disasm</code> function. Allocation in a hot loop is less than ideal, and we pray that whatever allocator they are using is thread-safe. The code runs fast enough for now, though, so no need to patch Capstone internals or use <a href="https://github.com/capstone-engine/capstone/blob/accf4df62f1fba6f92cae692985d27063552601c/include/capstone/capstone.h#L242-L248"><code>cs_opt_mem</code></a>.<a href="#fnref5" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn6" role="doc-endnote"><p>In the latest version of Zig (0.15.2), released right before this was published, <a href="https://ziglang.org/download/0.15.1/release-notes.html#reworked-stdcompressflate">the INFLATE API was changed</a> to accommodate the <a href="https://ziglang.org/download/0.15.1/release-notes.html#New-stdIoWriter-and-stdIoReader-API">new reader and writer API</a>. Those changes are probably related to the <a href="https://kristoff.it/blog/zig-new-async-io/">proposed async I/O implementation</a>. We don’t use them here because this code was written with an older version of Zig.<a href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn7" role="doc-endnote"><p>If we really wanted to display statistics while the code runs, we could rewrite the loop to use <a href="https://ziglang.org/documentation/0.14.1/std/#std.atomic.Value">lock-free atomics</a> for each of the totals. Here, we elide progress updates in the interest of keeping the code simple.<a href="#fnref7" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn8" role="doc-endnote"><p>In practice, it’s not exactly an enum. Otherwise we would be able to use it with <a href="https://ziglang.org/documentation/0.14.1/std/#std.EnumArray"><code>std.EnumArray</code></a> instead of rolling our own <code>counts</code> array indexing.<a href="#fnref8" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn9" role="doc-endnote"><p>When looking at the bytes themselves, the “first bit” here actually refers to the least significant bit of the first byte. In the RFC, the bytes are arranged from right to left, so the first bit of the stream is the rightmost bit.<a href="#fnref9" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn10" role="doc-endnote"><p>Similar to the first bit, the second and third bits here are actually the second and third least significant bits of the first byte. They are also reversed when serialized into the stream. Blame the authors of the DEFLATE RFC or maybe <a href="https://en.wikipedia.org/wiki/Phil_Katz">Phil Katz</a> of <a href="https://en.wikipedia.org/wiki/PKZIP">PKZIP</a> fame for this confusing situation.<a href="#fnref10" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn11" role="doc-endnote"><p>This is an upper bound because the decompressor returned early if it hit an error. It would only process the full ~120GB of data if all of the buffers were valid. Instead, it processed <em>at most</em> 120GB.<a href="#fnref11" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
<footer>
<hr />
<p>Copyright &copy; 2025 <a href="/about">Jacob Strieb</a>. All rights reserved.</p>
</footer>
</body>
</html>
